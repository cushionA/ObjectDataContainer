using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Linq;

namespace ToolCodeGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class ODCGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // ContainerSettingAttributeが付いたクラスを検出
            var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                typeof(ContainerSettingAttribute).FullName,　// 解析対象クラスについたアトリビュート
                static (node, token) => node is ClassDeclarationSyntax, // クラスの解析情報だけをフィルター
                static (classContext, token) => classContext);// クラスの解析情報をそのまま渡すという意味のデリゲート

            context.RegisterSourceOutput(source, GenerateContainer);
        }

        static void GenerateContainer(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
        {
            var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
            var typeNode = (ClassDeclarationSyntax)source.TargetNode;
            var attribute = source.Attributes[0];

            // 型配列を取得
            var structTypes = GetTypesFromAttribute(attribute.ConstructorArguments[0]);
            var classTypes = GetTypesFromAttribute(attribute.ConstructorArguments[1]);

            if ( structTypes.Length == 0 && classTypes.Length == 0 )
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    DiagnosticDescriptors.EmptyTypeArrays,
                    typeNode.Identifier.GetLocation(),
                    typeSymbol.Name));
                return;
            }

            // 名前空間取得
            var namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? ""
                : typeSymbol.ContainingNamespace.ToDisplayString();

            // コード生成
            var code = GenerateContainerCode(typeSymbol.Name, namespaceName, structTypes, classTypes);
            context.AddSource($"{typeSymbol.Name}.Container.g.cs", code);
        }

        static INamedTypeSymbol[] GetTypesFromAttribute(TypedConstant argument)
        {
            return argument.Values
                .Select(v => v.Value as INamedTypeSymbol)
                .Where(t => t != null)
                .ToArray();
        }

        static string GenerateContainerCode(string className, string namespaceName, INamedTypeSymbol[] structTypes, INamedTypeSymbol[] classTypes)
        {
            // 各種コード片を生成
            var entryStruct = GenerateEntryStruct();
            var memoryLayoutStruct = GenerateMemoryLayoutStruct(structTypes);
            var fields = GenerateFields(structTypes, classTypes);
            var properties = GenerateProperties(classTypes);
            var initializeMethod = GenerateInitializeMethod(className, structTypes, classTypes);
            var addMethods = GenerateAddMethods(structTypes, classTypes);
            var removeMethods = GenerateRemoveMethods(structTypes, classTypes);
            var getMethods = GenerateGetMethods(structTypes, classTypes);
            var utilityMethods = GenerateUtilityMethods(structTypes, classTypes);
            var internalMethods = GenerateInternalMethods(structTypes);
            var disposeMethod = GenerateDisposeMethod();

            // 名前空間の開始と終了
            var namespaceStart = !string.IsNullOrEmpty(namespaceName) ? $"namespace {namespaceName}\n{{\n" : "";
            var namespaceEnd = !string.IsNullOrEmpty(namespaceName) ? "}\n" : "";

            // メインコードテンプレート
            return $$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600, CS8601, CS8602, CS8603, CS8604

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

{{namespaceStart}}    public unsafe partial class {{className}}
    {
{{entryStruct}}
{{memoryLayoutStruct}}
{{fields}}
{{properties}}
{{initializeMethod}}
{{addMethods}}
{{removeMethods}}
{{getMethods}}
{{utilityMethods}}
{{internalMethods}}
{{disposeMethod}}    }
{{namespaceEnd}}
""";
        }

        static string GenerateEntryStruct()
        {
            return """
        private partial struct Entry
        {
            public int HashCode;
            public int ValueIndex;
            public int NextInBucket;
        }

""";
        }

        static string GenerateMemoryLayoutStruct(INamedTypeSymbol[] structTypes)
        {
            var offsets = string.Join("\n", structTypes.Select(type =>
                $"            public int {type.Name}Offset;"));

            return $$"""
        private struct MemoryLayout
        {
{{offsets}}
            public int TotalSize;
        }

""";
        }

        static string GenerateFields(INamedTypeSymbol[] structTypes, INamedTypeSymbol[] classTypes)
        {
            var unsafeLists = string.Join("\n", structTypes.Select(type =>
                $"        private UnsafeList<{type.ToDisplayString()}> _{ToCamelCase(type.Name)};"));

            var arrays = string.Join("\n", classTypes.Select(type =>
                $"        private {type.ToDisplayString()}[] _{ToCamelCase(type.Name)}s;"));

            return $$"""
        #region フィールド

        /// <summary>
        /// バケット配列（各要素はエントリへのインデックス、-1は空）
        /// </summary>
        private int[] _buckets;

        /// <summary>
        /// エントリのリスト（ハッシュ→インデックスのマッピング）
        /// </summary>
        private UnsafeList<Entry> _entries;

        /// <summary>
        /// エントリ削除後の使いまわせるスペースのインデックス
        /// </summary>
        private Stack<int> _freeEntry;

        /// <summary>
        /// 一括確保したメモリブロック
        /// </summary>
        private byte* _bulkMemory;
        private int _totalMemorySize;

        /// <summary>
        /// 現在の要素数
        /// </summary>
        private int _count;

        /// <summary>
        /// 最大容量
        /// </summary>
        private int _maxCapacity;

        /// <summary>
        /// メモリアロケータ
        /// </summary>
        private Allocator _allocator;

        /// <summary>
        /// 解放済みフラグ
        /// </summary>
        private bool _isDisposed;

        #region 管理対象のデータ

{{unsafeLists}}

{{arrays}}

        #endregion

        #endregion

""";
        }

        static string GenerateProperties(INamedTypeSymbol[] classTypes)
        {
            var spanProperties = string.Join("\n", classTypes.Select(type =>
                $"        public Span<{type.ToDisplayString()}> Get{type.Name}s => _{ToCamelCase(type.Name)}s.AsSpan().Slice(0, _count);"));

            return $$"""
        #region プロパティ（生成）

        /// <summary>
        /// 現在の要素数
        /// </summary>
        public int Count => _count;

        /// <summary>
        /// 最大容量
        /// </summary>
        public int MaxCapacity => _maxCapacity;

        /// <summary>
        /// 使用率（0.0～1.0）
        /// </summary>
        public float UsageRatio => (float)_count / _maxCapacity;

{{spanProperties}}

        #endregion

""";
        }

        static string GenerateInitializeMethod(string className, INamedTypeSymbol[] structTypes, INamedTypeSymbol[] classTypes)
        {
            var unsafeListInits = string.Join("\n", structTypes.Select(type => $$"""
            _{{{ToCamelCase(type.Name)}}} = new UnsafeList<{{{type.ToDisplayString()}}}>(
                ({{{type.ToDisplayString()}}*)(_bulkMemory + layout.{{{type.Name}}}Offset),
                maxCapacity);
            _{{{ToCamelCase(type.Name)}}}.Length = 0;
            """));

            var arrayInits = string.Join("\n", classTypes.Select(type =>
                $"            _{ToCamelCase(type.Name)}s = new {type.ToDisplayString()}[maxCapacity];"));

            return $$"""
        #region 初期化

        /// <summary>
        /// コンテナの初期化処理
        /// </summary>
        partial void InitializeContainer(int maxCapacity, Allocator allocator)
        {
            _maxCapacity = maxCapacity;
            _allocator = allocator;
            _count = 0;
            _isDisposed = false;

            // バケット配列の初期化
            _buckets = new int[BUCKET_COUNT];
            _buckets.AsSpan().Fill(-1);

            // エントリリストの初期化
            _entries = new UnsafeList<Entry>(BUCKET_COUNT * 2, allocator);

            // 削除エントリ保管用のスタック作成
            _freeEntry = new Stack<int>(maxCapacity);

            // メモリレイアウト計算とメモリ確保
            MemoryLayout layout = CalculateMemoryLayout(maxCapacity);
            _totalMemorySize = layout.TotalSize;
            _bulkMemory = (byte*)UnsafeUtility.Malloc(_totalMemorySize, 64, allocator);
            UnsafeUtility.MemClear(_bulkMemory, _totalMemorySize);

            // データ構造の初期化
{{unsafeListInits}}

{{arrayInits}}
        }

        #endregion

""";
        }

        static string GenerateAddMethods(INamedTypeSymbol[] structTypes, INamedTypeSymbol[] classTypes)
        {
            var allParams = structTypes.Select(type => $"{type.ToDisplayString()} {ToCamelCase(type.Name)}")
                .Concat(classTypes.Select(type => $"{type.ToDisplayString()} {ToCamelCase(type.Name)}"))
                .ToArray();

            var paramNames = allParams.Select(p => p.Split(' ')[1]).ToArray();

            var updateAssignments = string.Join("\n",
                structTypes.Select(type => $"                _{ToCamelCase(type.Name)}[existingIndex] = {ToCamelCase(type.Name)};")
                .Concat(classTypes.Select(type => $"                _{ToCamelCase(type.Name)}s[existingIndex] = {ToCamelCase(type.Name)};")));

            var addAssignments = string.Join("\n",
                structTypes.Select(type => $"            _{ToCamelCase(type.Name)}.AddNoResize({ToCamelCase(type.Name)});")
                .Concat(classTypes.Select(type => $"            _{ToCamelCase(type.Name)}s[dataIndex] = {ToCamelCase(type.Name)};")));

            return $$"""
        #region 追加・更新

        /// <summary>
        /// GameObjectとデータを追加
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Add(GameObject obj{{(allParams.Length > 0 ? ", " : "")}}{{string.Join(", ", allParams)}})
        {
            if (obj == null) throw new ArgumentNullException(nameof(obj));
            return AddByHash(obj.GetHashCode(){{(paramNames.Length > 0 ? ", " : "")}}{{string.Join(", ", paramNames)}});
        }

        /// <summary>
        /// ハッシュコードでデータを追加
        /// </summary>
        public int AddByHash(int hashCode{{(allParams.Length > 0 ? ", " : "")}}{{string.Join(", ", allParams)}})
        {
            if (TryGetIndexByHash(hashCode, out int existingIndex))
            {
{{updateAssignments}}
                return existingIndex;
            }

            if (_count >= _maxCapacity)
                throw new InvalidOperationException($"Maximum capacity ({_maxCapacity}) exceeded");

            int dataIndex = _count;

{{addAssignments}}

            RegisterToHashTable(hashCode, dataIndex);
            _count++;
            return dataIndex;
        }

        #endregion

""";
        }

        static string GenerateRemoveMethods(INamedTypeSymbol[] structTypes, INamedTypeSymbol[] classTypes)
        {
            var swapBackCalls = string.Join("\n", structTypes.Select(type =>
                $"                _{ToCamelCase(type.Name)}.RemoveAtSwapBack(dataIndex);"));

            var arraySwaps = string.Join("\n", classTypes.Select(type =>
                $"                _{ToCamelCase(type.Name)}s[dataIndex] = _{ToCamelCase(type.Name)}s[lastIndex];"));

            var lengthDecrements = string.Join("\n", structTypes.Select(type =>
                $"                _{ToCamelCase(type.Name)}.Length--;"));

            var nullAssignments = string.Join("\n", classTypes.Select(type =>
                $"            _{ToCamelCase(type.Name)}s[lastIndex] = null;"));

            return $$"""
        #region 削除（スワップ削除）

        /// <summary>
        /// GameObjectを削除
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Remove(GameObject obj)
        {
            if (obj == null) return false;
            return RemoveByHash(obj.GetHashCode());
        }

        /// <summary>
        /// ハッシュコードで削除
        /// </summary>
        public bool RemoveByHash(int hashCode)
        {
            if (!TryGetIndexByHash(hashCode, out int dataIndex)) return false;

            int lastIndex = _count - 1;
            if (dataIndex != lastIndex)
            {
{{swapBackCalls}}
{{arraySwaps}}
            }
            else
            {
{{lengthDecrements}}
            }

{{nullAssignments}}

            RemoveFromHashTable(hashCode);
            _count--;
            return true;
        }

        #endregion

""";
        }

        static string GenerateGetMethods(INamedTypeSymbol[] structTypes, INamedTypeSymbol[] classTypes)
        {
            var outParams = structTypes.Select(type => $"out {type.ToDisplayString()} {ToCamelCase(type.Name)}")
                .Concat(classTypes.Select(type => $"out {type.ToDisplayString()} {ToCamelCase(type.Name)}"))
                .Concat(new[] { "out int index" })
                .ToArray();

            var paramNames = outParams.Select(p => p.Split(' ')[1]).ToArray();

            var defaultAssignments = string.Join("\n",
                structTypes.Select(type => $"                {ToCamelCase(type.Name)} = default;")
                .Concat(classTypes.Select(type => $"                {ToCamelCase(type.Name)} = null;")));

            var valueAssignments = string.Join("\n",
                structTypes.Select(type => $"                {ToCamelCase(type.Name)} = _{ToCamelCase(type.Name)}[dataIndex];")
                .Concat(classTypes.Select(type => $"                {ToCamelCase(type.Name)} = _{ToCamelCase(type.Name)}s[dataIndex];")));

            var failureAssignments = string.Join("\n",
                structTypes.Select(type => $"            {ToCamelCase(type.Name)} = default;")
                .Concat(classTypes.Select(type => $"            {ToCamelCase(type.Name)} = null;")));

            var individualGetMethods = string.Join("\n\n", structTypes.Select(type => $$"""
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref {{{type.ToDisplayString()}}} Get{{{type.Name}}}ByIndex(int index)
        {
            if (index < 0 || index >= _count)
                throw new ArgumentOutOfRangeException(nameof(index));
            return ref _{{{ToCamelCase(type.Name)}}}.ElementAt(index);
        }
        """));

            return $$"""
        #region データ取得

        /// <summary>
        /// GameObjectからデータを取得
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetValue(GameObject obj{{(outParams.Length > 0 ? ", " : "")}}{{string.Join(", ", outParams)}})
        {
            if (obj == null)
            {
{{defaultAssignments}}
                index = -1;
                return false;
            }
            return TryGetValueByHash(obj.GetHashCode(), {{string.Join(", ", paramNames)}});
        }

        /// <summary>
        /// ハッシュコードからデータを取得
        /// </summary>
        public bool TryGetValueByHash(int hashCode{{(outParams.Length > 0 ? ", " : "")}}{{string.Join(", ", outParams)}})
        {
            if (TryGetIndexByHash(hashCode, out int dataIndex))
            {
{{valueAssignments}}
                index = dataIndex;
                return true;
            }

{{failureAssignments}}
            index = -1;
            return false;
        }

        /// <summary>
        /// インデックスからデータを取得
        /// </summary>
        public bool TryGetByIndex(int index{{(outParams.Length > 0 ? ", " : "")}}{{string.Join(", ", outParams)}})
        {
            if (index < 0 || index >= _count)
            {
{{failureAssignments}}
                return false;
            }

{{valueAssignments.Replace("dataIndex", "index")}}
            return true;
        }

{{individualGetMethods}}

        #endregion

""";
        }

        static string GenerateUtilityMethods(INamedTypeSymbol[] structTypes, INamedTypeSymbol[] classTypes)
        {
            var lengthResets = string.Join("\n", structTypes.Select(type =>
                $"            _{ToCamelCase(type.Name)}.Length = 0;"));

            var arrayClears = string.Join("\n", classTypes.Select(type =>
                $"            Array.Clear(_{ToCamelCase(type.Name)}s, 0, _count);"));

            return $$"""
        #region ユーティリティ（生成）

        /// <summary>
        /// データクリア処理
        /// </summary>
        partial void ClearAllData()
        {
            // バケットをリセット
            _buckets.AsSpan().Fill(-1);

            // エントリとマッピングをクリア
            _entries.Clear();

            // データをクリア
{{lengthResets}}
{{arrayClears}}

            _count = 0;
        }

        /// <summary>
        /// 指定したキーが存在するか確認
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsKey(GameObject obj)
        {
            if ( obj == null )
            {
                return false;
            }

            return ContainsKeyByHash(obj.GetHashCode());
        }

        /// <summary>
        /// 指定したハッシュコードが存在するか確認
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsKeyByHash(int hashCode)
        {
            return TryGetIndexByHash(hashCode, out int _);
        }

        #endregion

""";
        }

        static string GenerateInternalMethods(INamedTypeSymbol[] structTypes)
        {
            var layoutCalculations = string.Join("\n\n", structTypes.Select(type => $$"""
            layout.{{{type.Name}}}Offset = currentOffset;
            currentOffset += capacity * sizeof({{{type.ToDisplayString()}}});
            currentOffset = AlignTo(currentOffset, 64);
            """));

            return $$"""
        #region 内部メソッド

        private const int DEFAULT_MAX_CAPACITY = 130;
        private const int BUCKET_COUNT = 191;  // 素数を使用
        
        private MemoryLayout CalculateMemoryLayout(int capacity)
        {
            MemoryLayout layout = new();
            int currentOffset = 0;

{{layoutCalculations}}

            layout.TotalSize = currentOffset;
            return layout;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int AlignTo(int memoryOffset, int alignment)
        {
            return (memoryOffset + alignment - 1) & ~(alignment - 1);
        }

        /// <summary>
        /// バケットインデックスの計算
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private int GetBucketIndex(int hashCode)
        {
            return (hashCode & 0x7FFFFFFF) % BUCKET_COUNT;
        }

        /// <summary>
        /// ハッシュ値から値のインデックスを取得する
        /// </summary>
        public bool TryGetIndexByHash(int hashCode, out int index)
        {
            int bucketIndex = GetBucketIndex(hashCode);
            int entryIndex = _buckets[bucketIndex];

            while ( entryIndex != -1 )
            {
                ref Entry entry = ref _entries.ElementAt(entryIndex);

                if ( entry.HashCode == hashCode )
                {
                    index = entry.ValueIndex;
                    return true;
                }

                entryIndex = entry.NextInBucket;
            }

            index = -1;
            return false;
        }

        /// <summary>
        /// ハッシュテーブルにエントリを登録
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RegisterToHashTable(int hashCode, int dataIndex)
        {
            int bucketIndex = GetBucketIndex(hashCode);
            Entry newEntry = new()
            {
                HashCode = hashCode,
                ValueIndex = dataIndex,
                NextInBucket = _buckets[bucketIndex]
            };
            int newEntryIndex;
            if ( _freeEntry.TryPop(out newEntryIndex) )
            {
                _entries[newEntryIndex] = newEntry;
            }
            else
            {
                newEntryIndex = _entries.Length;
                _entries.AddNoResize(newEntry);
            }
            _buckets[bucketIndex] = newEntryIndex;
        }

        /// <summary>
        /// エントリのデータインデックスを更新
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void UpdateEntryDataIndex(int hashCode, int newDataIndex)
        {
            int bucketIndex = GetBucketIndex(hashCode);
            int entryIndex = _buckets[bucketIndex];
            while ( entryIndex != -1 )
            {
                ref Entry entry = ref _entries.ElementAt(entryIndex);
                if ( entry.HashCode == hashCode )
                {
                    entry.ValueIndex = newDataIndex;
                    return;
                }
                entryIndex = entry.NextInBucket;
            }
        }

        /// <summary>
        /// ハッシュテーブルからエントリを削除
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RemoveFromHashTable(int hashCode)
        {
            int bucketIndex = GetBucketIndex(hashCode);
            int entryIndex = _buckets[bucketIndex];
            int prevIndex = -1;
            while ( entryIndex != -1 )
            {
                ref Entry entry = ref _entries.ElementAt(entryIndex);
                if ( entry.HashCode == hashCode )
                {
                    if ( prevIndex == -1 )
                    {
                        _buckets[bucketIndex] = entry.NextInBucket;
                    }
                    else
                    {
                        ref Entry prevEntry = ref _entries.ElementAt(prevIndex);
                        prevEntry.NextInBucket = entry.NextInBucket;
                    }
                    _freeEntry.Push(entryIndex);
                    return;
                }
                prevIndex = entryIndex;
                entryIndex = entry.NextInBucket;
            }
        }

        #endregion

""";
        }

        static string GenerateDisposeMethod()
        {
            return """
        #region リソース解放

        /// <summary>
        /// リソース解放処理
        /// </summary>
        partial void DisposeResources()
        {
            if ( _isDisposed )
            {
                return;
            }

            if ( _bulkMemory != null )
            {
                UnsafeUtility.Free(_bulkMemory, _allocator);
                _bulkMemory = null;
            }

            _entries.Dispose();

            _isDisposed = true;
        }

        #endregion

""";
        }

        static string ToCamelCase(string input)
        {
            if ( string.IsNullOrEmpty(input) )
                return input;
            return char.ToLowerInvariant(input[0]) + input.Substring(1);
        }
    }

    public static class DiagnosticDescriptors
    {
        const string Category = "ContainerGenerator";

        public static readonly DiagnosticDescriptor EmptyTypeArrays = new(
            id: "CG001",
            title: "Empty type arrays",
            messageFormat: "ContainerSetting attribute for class '{0}' has empty type arrays",
            category: Category,
            defaultSeverity: DiagnosticSeverity.Warning,
            isEnabledByDefault: true);
    }
}